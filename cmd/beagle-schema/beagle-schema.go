// Copyright 2019 The DutchSec Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"unicode"

	jsonschema "github.com/santhosh-tekuri/jsonschema"
	"gopkg.in/yaml.v2"
)

// Field name sanitizer.
type Ident string

// Golang identifiers must begin with a letter and may contain letters, digits
// and _'s. If config.titleCase is true, -, _ and spaces are treated as word
// boundaries, otherwise only spaces are treated as word boundaries.
func (id Ident) String() (s string) {
	// Trim non-letter characters from the left of the identifier.
	s = strings.TrimLeftFunc(string(id), func(r rune) bool {
		return !unicode.IsLetter(r)
	})

	// Remove any invalid characters in the identifier.
	s = strings.Map(func(r rune) rune {
		if r == ' ' {
			return ' '
		}

		// Convert -'s to _'s or spaces depending on configuration.
		if r == '-' || r == '_' {
			if true /*config.titleCase */ {
				return ' '
			}
			return '_'
		}

		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			return r
		}

		return -1
	}, s)

	// Perform title casing.
	s = strings.Title(s)
	// Remove spaces from the identifier.
	s = strings.Map(func(r rune) rune {
		if r == ' ' {
			return -1
		}
		return r
	}, s)

	// If the identifier is empty, output an _.
	if len(s) == 0 {
		s = "_"
	}

	// only suffix?
	s = strings.Replace(s, "Id", "ID", -1)
	s = strings.Replace(s, "Url", "URL", -1)
	return
}

func getType(pschema *jsonschema.Schema) string {
	if ref := pschema.Ref; ref != nil {
		// from config yaml?
		// $utils.UUID?
		if ref.URL == "uuid.json" {
			return "utils.UUID"
		} else if ref.URL == "beacon.json" {
			return "Beacon"
		} else if ref.URL == "trigger.json" {
			return "Trigger"
		}
	}

	//recursive in case of type=object
	// pschema.Properties
	//fmt.Printf("%#+v\n", pschema.Types)

	if len(pschema.Types) == 0 {
		// error!
	} else if len(pschema.Types) == 1 {
		if pschema.Types[0] == "array" {
			fmt.Printf("%#+v\n", pschema.Items)
			if is, ok := pschema.Items.(*jsonschema.Schema); ok {
				// assume ref
				return fmt.Sprintf("[]%s", getType(is))
			}
		} else {
			return (pschema.Types[0])
		}
	}

	return "interface{}"
}

type Generator struct {
	buf bytes.Buffer
}

func (g *Generator) Printf(format string, a ...interface{}) {
	fmt.Fprintf(&g.buf, format, a...)
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

type Config struct {
	Package string   `yaml:"package"`
	Imports []string `yaml:"imports"`
}

func main() {
	var config Config
	if source, err := ioutil.ReadFile("config.yaml"); err != nil {
		panic(err)
	} else if err := yaml.Unmarshal(source, &config); err != nil {
		panic(err)
	}

	fmt.Printf("%#+v", config)

	// walk through json
	// make go schem
	packageName := config.Package

	for _, arg := range os.Args[1:] {
		glob, err := filepath.Glob(arg)
		if err != nil {
			log.Fatal("Error globbing: %s: %s", arg, err.Error())
		}

		for _, fileName := range glob {
			schema, err := jsonschema.Compile(fileName)
			if err != nil {
				panic(err.Error())
			}

			/*
				fmt.Printf("%#+v", schema)
				for name, schema := range schema.Properties {
					fmt.Printf("name=%#+v\n\nschema=%#+v\n\nref=%#+v", name, schema, schema.Ref)
				}
			*/

			g := Generator{}

			// Print the header and package clause.
			g.Printf("// Code generated by \"beagle schema %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
			g.Printf("package %s", packageName)
			g.Printf("\n")
			g.Printf("import (\n")
			for _, import_ := range config.Imports {
				g.Printf("%s\n", import_)
			}

			g.Printf(")\n")

			parts := strings.Split(filepath.Base(fileName), ".")
			name := Ident(parts[0])
			fmt.Println(name)

			g.Printf("type %s struct {\n", name)

			for name, pschema := range schema.Properties {
				// fmt.Printf("name=%#+v\n\nschema=%#+v\n\nref=%#+v", name, pschema, pschema.Ref)
				// check required
				// pointer to

				type_ := getType(pschema)
				g.Printf("%s %s `json:\"%s,omitempty\"`\n", Ident(name), type_, name)

			}

			g.Printf("}\n")

			g.Printf("func (v %s) Validate(o interface{}) error {\n", name)

			// check if required
			g.Printf("return nil\n")
			g.Printf("}\n")

			src := g.format()

			// Write to file.
			outputName := "" // *output
			if outputName == "" {
				parts := strings.Split(filepath.Base(fileName), ".")
				baseName := fmt.Sprintf("%s_gen.go", parts[0])
				outputName = filepath.Join(".", strings.ToLower(baseName))
			}

			src, err = goimports(outputName, src)
			if err != nil {
				log.Fatalf("Error executing goimport: %s", err.Error())
			}

			if err := ioutil.WriteFile(outputName, src, 0644); err != nil {
				log.Fatalf("writing output: %s", err)
			}
		}
	}
}

// Run goimports to format and update imports statements in generated code.
func goimports(filename string, inputBytes []byte) (outputBytes []byte, err error) {
	if false {
		return inputBytes, nil
	}
	cmd := exec.Command("goimports")
	// cmd := exec.Command(os.Getenv("GOPATH") + "/bin/goimports")
	input, _ := cmd.StdinPipe()
	output, _ := cmd.StdoutPipe()
	cmderr, _ := cmd.StderrPipe()
	err = cmd.Start()
	if err != nil {
		return
	}
	input.Write(inputBytes)
	input.Close()

	outputBytes, _ = ioutil.ReadAll(output)
	errors, _ := ioutil.ReadAll(cmderr)
	if len(errors) > 0 {
		errors := strings.Replace(string(errors), "<standard input>", filename, -1)
		log.Printf("Syntax errors in generated code:\n%s", errors)
		return inputBytes, nil
	}

	return
}
